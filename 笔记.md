# Tomcat

## Tomcat配置文件
```xml
<?xml version="1.0" encoding="UTF-8"?>
<Server port="8005" shutdown="SHUTDOWN">
  <Listener className="org.apache.catalina.startup.VersionLoggerListener" />
  <Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />
  <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" />
  <Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" />
  <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" />

  <GlobalNamingResources>
    <Resource name="UserDatabase" auth="Container"
              type="org.apache.catalina.UserDatabase"
              description="User database that can be updated and saved"
              factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
              pathname="conf/tomcat-users.xml" />
  </GlobalNamingResources>

  <Service name="Catalina">



<Connector port="8081" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443"/>

<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol" maxThreads="150" SSLEnabled="true">
        <SSLHostConfig>
           <Certificate certificateKeystoreFile="D:/liuyx.keystore" type="RSA" certificateKeystoreType="JKS" certificateKeystorePassword="123456"/>
        </SSLHostConfig>
</Connector>


    <Engine name="Catalina" defaultHost="localhost">
    
      <Realm className="org.apache.catalina.realm.LockOutRealm">
        <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
               resourceName="UserDatabase"/>
      </Realm>
    
      <Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true">
    
        <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="localhost_access_log" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
    
      </Host>
    </Engine>
  </Service>
</Server>
```
## tomcat全局组件

![image-20211025194612498](image-20211025194612498.png)

### 1.Server组件

​	Server组件是代表整个Tomcat的Servlet容器，属于最外层组件，主要功能：

​	①提供监听功能，对Tomcat整个生命周期中的不同事件进行处理，比如当web应用重新加载时，ThreadLocal会产生内存泄漏，监听器会堵住线程池，并重新创建线程。

​	②监听某个端口以接收SHUTDOWN命令。

​	③提供了Tomcat容器全局的命名资源实现。

### 2.Service组件

​	Service组件是若干Connector和Executor组成，配置多个Connector可以监听多个端口，如果需要端口单独监听一个项目，就要再添加一个Service组件，并设置Host中的读取目录(webapps2)。

### 3.Connector组件

​	①Protocol组件是协议的抽象，对不同协议进行了封装，HTTP协议、AJP协议。

​	②Endpoint组件存在多种I/O模式，BIO模式的JioEndpoint、NIO模式的NioEndpoint、本地库I/O模式AprEndpoint。

​	BIO模式下，操作系统接收到HTTP请求后，LimitLatch会控制连接数量，达到限制流量的目的。Acceptor会监听是否有客户端套接字（Request），并接收Socket。将连接交由线程池Executor处理后返回操作系统（Response）。如果是HTTPS请求会在LimitLatch前面加入ServerSocketFactory组件实现SSL/TLS协议。

![image-20211026110655718](image-20211026110655718.png)

​	NIO模式下，如果是HTTPS请求，则使用SecureNioChannel处理，有多个Poller组成Poller池，所有连接使用轮询调度算法均摊给每个Poller处理，Poller连接轮询器去不断遍历事件列表，一旦发现相应的事件则封装成任务定义器SocketProcessor，并扔进线程池Executor中执行任务，如果没有Executor组件，Poller会自己处理任务。

![image-20211026202610047](image-20211026202610047.png)

### 4.Engine容器

​	Engine容器为全局引擎容器，主要组件有Host组件、AccessLog组件、Pipeline组件、Cluster组件、Realm组件、LifecycleListener组件、Log组件。

​	①Host组件表示一个虚拟主机

​	②AccessLog组件负责客户端请求访问日志的记录，不管访问哪个Host都会被记录。

​	③Pipeline组是件可以将不通容器级别串联起来的通道，Tomcat中有4个级别的容器。

​	④Cluster组件负责配置集群

​	⑤Realm组件其实是一个存储了用户、密码及权限等数据的对象，存储方式可能是内存、xml文件或数据库等，主要作用是配合Tomcat实现资源认证模块。

​	⑥LifecycleListener组件

![image-20211027175103581](image-20211027175103581.png)

### 5.Host容器

​	Host容器用于表示虚拟主机，是根据URL地址中的主机部分抽象的，一个Servlet引擎可以包含若干个Host容器，一个Host容器可以包含若干个Context容器、AccessLog组件、Pipeline组件、Cluster组件、Realm组件、Log组件（以上重复组件功能与Engine中的组件相同，只是作用范围不同）、HostConfig组件。

​	HostConfig组件：生命周期监听器，用于处理不同类型的Web应用。同时加载多个项目时，使用Future进行线程协调

​		①直接在配置文件<Context/>标签中配置目录，到目录找到context.xml解析后进行部署

​		②在Host配置的目录下（webapps）导入war包，读取war包里的context.xml文件后进行部署

​		③目录部署，直接放到webapps下，读取META-INF/context.xml文件

![image-20211027201342554](image-20211027201342554.png)

### 6.Context容器 (web.xml)

​	一个Context对应一个Web应用程序，Context容器包含若干Wrapper组件、Realm组件、AccessLog组件、ErrorPage组件、Manager组件、DirContext组件、安全认证组件、JarScanner组件、过滤器组件、NamingResource组件、Mapper组件、Pipeline组件、WebappLoader组件、ApplicationContext组件、InstanceManager组件、ServletContainerInitializer组件、Listeners组件。

![image-20211102205345582](image-20211102205345582.png)

#### WebappLoader Web应用载入器  

​	WebappLoader的核心工作是交给WebappClassLoader类加载器来完成类加载工作，它是一个自定义的类加载器，WebappClassLoader继承了URLClassLoader，只需要把/WEB-INF/lib 和/WEB-INF/classes目录下的类以URL的形式添加到URLClassLoader中，后面就可以使用该类加载器对类进行加载。

​	实现互相隔离：

​	WebappClassLoader没有遵循双亲委派机制，而是按照自己的策略顺序加载类，根据委托标识，加载分为两种方式。

​	①当委托标识delegate为false时，WebappClassLoader类加载器首先尝试从本地缓存中加载该类，然后用System类加载器尝试加载，接着由自己尝试加载类，最后才由父类加载器(Common)加载。

​	②当委托标识delegate为true时，WebappClassLoader类加载器首先尝试从本地缓存中加载该类，然后用System类加载器尝试加载类，接着由父类加载器(Common)尝试加载，最后由自己加载。

​	对于公共资源可以共享，但属于Web应用的资源则通过类加载器进行了隔离。

​	实现重加载：

​	只需要重新实例化一个WebappClassLoader对象并把原来的WebappLoader中旧的置换掉即可完成重加载功能，置换掉的将会被GC回收。

​	System ClassLoader = Application ClassLoader

![image-20211104232646586](image-20211104232646586.png)

#### ApplicationContext

​	在Servlet的规范中规定了一个ServletContext接口，ApplicationContext实现了ServletContext接口，但实际上getServletContext()获取到的并非ApplicationContext对象，而是ApplicationContextFacade门面对象。

#### InstanceManager实例管理器

Context容器中包含了一个实例管理器，主要作用是实现对Context容器中监听器、过滤器以及Servlet等实例的管理。InstanceManager包含了两个类加载器，一个属于Tomcat容器内部的类加载器，另一个属于Web应用的类加载器。Tomcat容器类加载器是Web应用类加载器的父类加载器，Tomcat加载器在Tomcat整个生命周期中都会存在，Web加载器可能在重启后被丢弃，最终被GC。

# CAS单点登录

登录

https://juejin.cn/post/6844903651320791048

 [终于搞明白了，CAS单点登录原理解析！！ - 掘金.pdf](终于搞明白了，CAS单点登录原理解析！！ - 掘金.pdf) 

登出

https://www.cnblogs.com/xiangkejin/p/8963089.html

在请求Cas Server的logout时，Cas Server会将客户端携带的TGC删除，同时回调该TGT对应的所有service，即所有的Cas Client。

Cas Client如果需要响应该回调，进而在Cas Client端进行登出操作的话就需要有对应的支持。



# ANTLR4

```java
获取原本格式
ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));
```

# Java类加载

## 类加载过程

类的加载分为**加载**—>**链接**—>**初始化**

在链接阶段又有**验证**—>**准备**—>**解析**

![image-20211110180123096](image-20211110180123096.png)

**//TODO链接，初始化详细过程**

## 双亲委派

![image-20211110231116375](image-20211110231116375.png)

​	接收加载请求的类加载器叫做***初始类加载器(initiating loader)**,完成加载的类加载器叫做**定义类加载器(defining loder)**,初始类加载器和定义类加载器可能相同也可能不同。

​	类加载过程中有三个重要的方法：**loadClass()、findClass()  defineClass()**

​	打破双亲委派机制可以重写loadClass()，但如果完全打破会导致不能使用核心类库，Tomcat的实现是先使用自己的类加载器之后在进入到双亲委派机制中。**//TODO 调试Tomcat源码**

​	重写findClass()可以到指定目录下获取类进行加载。

​	defineClass() 方法主要是把字节数组转化为类的实例。同时definClass方法为final的，故不可以覆写。调用 defineClass 方法时，会对字节流进行校验，校验不通过会抛出 ClassFormatError 异常。字节流可以来源于.class文件，也可来自网络或其他途径。

```java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
    	 // 一个类的加载是放在代码同步块里边的，所以不会有同一个类加载多次
        synchronized (getClassLoadingLock(name)) {
            // 首先检查该类是否已加载过
            Class<?> c = findLoadedClass(name);
            // 如果缓存中没有找到，则按双亲委派模型加载
            if (c == null) {
                try {
                    if (parent != null) {
                    	// 如果父加载器不为null，则代理给父加载器加载
                    	// 父加载器在自己搜索范围内找不到该类，则抛出ClassNotFoundException
                        c = parent.loadClass(name, false);
                    } else {
                    	// 如果父加载器为null，则从引导类加载器加载过的类中
                    	// 找是否加载过此类，找不到返回null
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 存在父加载器但父加载器没有找到要加载的类触发此异常
                    // 只捕获不处理，交给字加载器自身去加载
                }

            if (c == null) {
                // 如果从父加载器到顶层加载器（引导类加载器）都找不到此类，则自己来加载
                c = findClass(name);
            }
        }
        
        // 如果resolve指定为true，则立即进入链接阶段
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

​	ApplicationClassLoader.getParent() = ExtensionClassLoader;

​	ApplicationClassLoader的父类是ExtensionClassLoader。

​	ExtensionClassLoader的父类不是BootstrapClassLoader。

​	父类为空则使用BootstrapClassLoader。

​	BootstrapClassLoader是由C/C++编写的，它本身时虚拟机的一部分，并不是Java类，无法在java代码中获取引用。

**getClassLoadingLock**

```java
protected Object getClassLoadingLock(String className) {
    Object lock = this;
    if (parallelLockMap != null) {
        Object newLock = new Object();
        lock = parallelLockMap.putIfAbsent(className, newLock);
        if (lock == null) {
            lock = newLock;
        }
    }
    return lock;
}

private ClassLoader(Void unused, ClassLoader parent) {
    this.parent = parent;
    if (ParallelLoaders.isRegistered(this.getClass())) {
        parallelLockMap = new ConcurrentHashMap<>();
        package2certs = new ConcurrentHashMap<>();
        assertionLock = new Object();
    } else {
        // no finer-grained lock; lock on the classloader instance
        parallelLockMap = null;
        package2certs = new Hashtable<>();
        assertionLock = this;
    }
}
```

​	classLoader加载器初始化时会创建parallelLockMap，key为ClassName，value为Object锁对象，加载时会尝试获取锁对象，没有则新建。

​	可以确保类可以并发加载。

​	putIfAbsent方法主要是在向ConcurrentHashMap中添加键—值对的时候，它会先判断该键值对是否已经存在。

返回值：
（1）如果是新的记录，那么会向map中添加该键值对，并返回null。
（2）如果已经存在，那么不会覆盖已有的值，直接返回已经存在的值。

## Launcher

​	sun.misc.Launcher是一个java虚拟机的入口应用。AppClassLoader和ExtClassLoader都是在Launcher中加载的。

```java
public Launcher() {
    Launcher.ExtClassLoader var1;
    try {
        //初始化加载扩展类加载器
        var1 = Launcher.ExtClassLoader.getExtClassLoader();
    } catch (IOException var10) {
        throw new InternalError("Could not create extension class loader", var10);
    }

    try {
        //初始化加载应用类加载器
        this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
    } catch (IOException var9) {
        throw new InternalError("Could not create application class loader", var9);
    }
	//设置线程上下文类加载器为AppClassLoader
    Thread.currentThread().setContextClassLoader(this.loader);
    String var2 = System.getProperty("java.security.manager");
    if (var2 != null) {
        SecurityManager var3 = null;
        if (!"".equals(var2) && !"default".equals(var2)) {
            try {
                //实例化安全管理器
                var3 = (SecurityManager)this.loader.loadClass(var2).newInstance();
            } catch (IllegalAccessException var5) {
            } catch (InstantiationException var6) {
            } catch (ClassNotFoundException var7) {
            } catch (ClassCastException var8) {
            }
        } else {
            var3 = new SecurityManager();
        }

        if (var3 == null) {
            throw new InternalError("Could not create SecurityManager: " + var2);
        }

        System.setSecurityManager(var3);
    }

}
```
## URLClassLoader

```java
static {
    SharedSecrets.setJavaNetAccess(new JavaNetAccess() {
        public URLClassPath getURLClassPath(URLClassLoader var1) {
            return var1.ucp;
        }

        public String getOriginalHostName(InetAddress var1) {
            return var1.holder.getOriginalHostName();
        }
    });
    ClassLoader.registerAsParallelCapable();
}
//将url添加到ucp
protected void addURL(URL url) {
    ucp.addURL(url);
}
```

​	URLClassLoader可以加载任意路径下的类，URLClassLoader继承于ClassLoader，是对于ClassLoader的扩展，ClassLoader只可以加载ClassPath下的类，URLClassLoader可以通过传入的URL地址进行加载。

​	ApplicationClassLoader和ExtensionClassLoaderd都继承了URLClassLoader,所以在初始化的过程中都会执行此静态代码块，将ucp(URLClassLoader) set 到SharedSecrets中。这样AppClassLoader的ucp中可以拿到ExtClassLoader的ucp。

```java
protected Class<?> findClass(final String var1) throws ClassNotFoundException {
    Class var2;
    try {
        var2 = (Class)AccessController.doPrivileged(new PrivilegedExceptionAction<Class<?>>() {
            public Class<?> run() throws ClassNotFoundException {
                String var1x = var1.replace('.', '/').concat(".class");
                //到ucp里面查找resource
                Resource var2 = URLClassLoader.this.ucp.getResource(var1x, false);
                if (var2 != null) {
                    try {
                        //找到这个class的话，执行defineClass()
                        return URLClassLoader.this.defineClass(var1, var2);
                    } catch (IOException var4) {
                        throw new ClassNotFoundException(var1, var4);
                    }
                } else {
                    return null;
                }
            }
        }, this.acc);
    } catch (PrivilegedActionException var4) {
        throw (ClassNotFoundException)var4.getException();
    }

    if (var2 == null) {
        throw new ClassNotFoundException(var1);
    } else {
        return var2;
    }
}
```
## ExtensionClassLoader

```java
static class ExtClassLoader extends URLClassLoader {
    private static volatile Launcher.ExtClassLoader instance;

    //单例模式获取实例
    public static Launcher.ExtClassLoader getExtClassLoader() throws IOException {
        if (instance == null) {
            Class var0 = Launcher.ExtClassLoader.class;
            synchronized(Launcher.ExtClassLoader.class) {
                if (instance == null) {
                    //创建ExtClassLoader
                    instance = createExtClassLoader();
                }
            }
        }

        return instance;
    }

    private static Launcher.ExtClassLoader createExtClassLoader() throws IOException {
        try {
            return (Launcher.ExtClassLoader)AccessController.doPrivileged(new PrivilegedExceptionAction<Launcher.ExtClassLoader>() {
                public Launcher.ExtClassLoader run() throws IOException {
                    //获取加载目录java.ext.dirs
                    File[] var1 = Launcher.ExtClassLoader.getExtDirs();
                    int var2 = var1.length;

                    for(int var3 = 0; var3 < var2; ++var3) {
                        MetaIndex.registerDirectory(var1[var3]);
                    }

                    return new Launcher.ExtClassLoader(var1);
                }
            });
        } catch (PrivilegedActionException var1) {
            throw (IOException)var1.getException();
        }
    }

    public ExtClassLoader(File[] var1) throws IOException {
        super(getExtURLs(var1), (ClassLoader)null, Launcher.factory);
        SharedSecrets.getJavaNetAccess().getURLClassPath(this).initLookupCache(this);
    }
    private static File[] getExtDirs() {
        String var0 = System.getProperty("java.ext.dirs");
        File[] var1;
        if (var0 != null) {
            StringTokenizer var2 = new StringTokenizer(var0, File.pathSeparator);
            int var3 = var2.countTokens();
            var1 = new File[var3];

            for(int var4 = 0; var4 < var3; ++var4) {
                var1[var4] = new File(var2.nextToken());
            }
        } else {
            var1 = new File[0];
        }

        return var1;
    }
}
```
## ApplicationClassLoader

```java
static class AppClassLoader extends URLClassLoader {
    ////此时ucp的值就是 AppClassLoader 父类 URLClassLoader 中的 ucp 
        final URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(this);

        public static ClassLoader getAppClassLoader(final ClassLoader var0) throws IOException {
            final String var1 = System.getProperty("java.class.path");
            final File[] var2 = var1 == null ? new File[0] : Launcher.getClassPath(var1);
            return (ClassLoader)AccessController.doPrivileged(new PrivilegedAction<Launcher.AppClassLoader>() {
                public Launcher.AppClassLoader run() {
                    URL[] var1x = var1 == null ? new URL[0] : Launcher.pathToURLs(var2);
                    return new Launcher.AppClassLoader(var1x, var0);
                }
            });
        }
        AppClassLoader(URL[] var1, ClassLoader var2) {
            super(var1, var2, Launcher.factory);
            this.ucp.initLookupCache(this);
        }
		// Class.forName 的 入口
        public Class<?> loadClass(String var1, boolean var2) throws ClassNotFoundException {
            int var3 = var1.lastIndexOf(46);//检查 类的 全路径中是否含有 . 号
            if (var3 != -1) {//含有.号
                SecurityManager var4 = System.getSecurityManager();
                if (var4 != null) {
                    var4.checkPackageAccess(var1.substring(0, var3));//检查 类 所在的 包（目录） 是否可以访问
                }
            }

            if (this.ucp.knownToNotExist(var1)) {
                Class var5 = this.findLoadedClass(var1);
                if (var5 != null) {
                    if (var2) {
                        this.resolveClass(var5);
                    }

                    return var5;
                } else {
                    throw new ClassNotFoundException(var1);
                }
            } else {
                //交给父类URLClassLoader->ClassLoader
                return super.loadClass(var1, var2);
            }
        }
}
```
​	ApplicationClassLoader和ExtensionClassLoaderd都继承了URLClassLoader，都传入了加载类的固定目录，ExtensionClassLoaderd本身没有实现findClass()，ApplicationClassLoader实现了loadClass()方法，**//TODO ApplicationClassLoader实现loadClass对于this.ucp.knownToNotExist(var1)单独处理**   但还是会调用到父类的loadClass()。URLClassLoader中没有实现loadClass()，调用类加载器中的loadClass()方法会调用到ClassLoader中的loadClass方法，ClassLoader中没有实现findClass()，会调用到URLClassLoader中的findClass()。

## Thread.currentThread().getContextClassLoader()

···

https://www.codeleading.com/article/70645146710/

https://zhuanlan.zhihu.com/p/51374915

https://blog.csdn.net/briblue/article/details/54973413

https://www.jianshu.com/p/5c2cd08dfe89

https://juejin.cn/post/6844903564804882445

